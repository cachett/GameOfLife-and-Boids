import java.util.ArrayList;
import java.util.Random;
import static java.lang.Math.*;


class Boid {
    private static final Random r = new Random();
    private Vector migrate = new Vector(0.01, 0.005);
    private double angleVision = 2.7; // demi vision
    private Vector location, velocity, acceleration;
    private double maxForce = 0.05;
    protected double maxSpeed = 3.8;
    private final int width, height;
    protected double desiredBorder = 120;
    protected double desiredSeparation = 28;
    protected double preferredDist = 50;


    //Constructor
    public Boid(double x, double y, int width, int height) {
        //a boid is caracterised by 3 vectors: acceleration, velocity and  location
        acceleration = new Vector();
        velocity = new Vector(r.nextInt(3) + 1, r.nextInt(3) - 1);
        location = new Vector(x, y);
        this.width = width;
        this.height = height;
    }

    //Copy
    public Boid(Boid boid){
      this.velocity = new Vector(boid.velocity);
      this.location = new Vector(boid.location);
      this.acceleration = new Vector(boid.acceleration);
      this.height = boid.height;
      this.width = boid.width;
    }


    /**
    *Update the 3 vectors of boid for the time n+1
    */
    public void update() {
        velocity.add(acceleration); // x'(n+1) = x'(n) + x''(n)
        velocity.limit(maxSpeed); //check if boid is not moving too fast
        location.add(velocity); // x(n+1) = x(n) + x'(n)
        keepInScreen();
        acceleration.mult(0); //acceleration restart everytime from 0, forces are reinitialized
    }

    /**
    *Application to the vector acceleration
    *all the forces generated by the flock
    */
    public void flock(ArrayList<Boid> boids) {
        Vector rule1 = separation(boids);
        Vector rule2 = alignment(boids);
        Vector rule3 = cohesion(boids);
        Vector rule4 = border();

        //We adjuste each law here
        rule1.mult(3.6);
        rule2.mult(1.4);
        rule3.mult(1.2);
        rule4.mult(1.8);

        applyForce(rule1);
        applyForce(rule2);
        applyForce(rule3);
        applyForce(rule4);
        applyForce(migrate);
    }

    /**
    *Keep the boid on the screen.
    *We consider that the screen is "circular".
    */
    public void keepInScreen(){
      location.x = ((location.x%width) + width )% width;
      location.y = ((location.y%height) + height)% height;
    }


    public Vector border(){
      /* Apply a force when the boid get close to the border so it will stay in the window */
      Vector steer = new Vector(0, 0);
      if (location.x < desiredBorder){
        steer.add(new Vector(1 -  pow(location.x/desiredBorder, 6), 0)); //norm of this force increase in x^6 when the boid get closer to the border
      } else if (location.x > width - desiredBorder){
        steer.add(new Vector(-1 + pow((width - desiredBorder)/location.x, 6), 0));
      }
      if (location.y < desiredBorder){
        steer.add(new Vector(0, 1 - pow(location.y/desiredBorder, 6)));
      } else if (location.y > height - desiredBorder){
        steer.add(new Vector(0, -1  +  pow((height - desiredBorder)/location.y, 6)));
      }
      if (steer.norm() > 0) {
          steer.normalize();
          steer.limit(maxForce);
      }

      return steer;
    }


    /**
    *Return the vector corresponding to
    *the force "separation" applied to the boid by his neighbours
    */
    public Vector separation(ArrayList<Boid> boids) {
        Vector steer = new Vector(0, 0);
        for (Boid b : boids) { //for all the boids
            double distance = Vector.dist(location, b.location);
            //d>0 because for the boid considered, it will be 0
            if ((distance > 0) && (distance < desiredSeparation) && (b.getClass()== this.getClass())) { // if another boid is too close...
                double angle = Vector.angleBetween(Vector.sub(velocity, location), Vector.sub(location, b.location)); //operation couteuse
                if (angle < angleVision){ //...and is on his field of vision
                    Vector diff = Vector.sub(location, b.location);
                    diff.normalize();
                    diff.div(distance); //closest neighbours will impact more the boid, so we need to adjust
                    steer.add(diff);
                }

            }
        }

        if (steer.norm() > 0) {
            steer.normalize();
            steer.mult(maxSpeed);
            steer.sub(velocity);
            steer.limit(maxForce);
        }
        return steer;
    }

    /**
    *Return the vector corresponding to
    *the force "alignment" applied to the boid by his neighbours
    */
    public Vector alignment(ArrayList<Boid> boids) {
        Vector steer = new Vector(0, 0);

        for (Boid b : boids) {
            double distance = Vector.dist(location, b.location);
            if ((distance > 0) && (distance < preferredDist)&& (b.getClass()== this.getClass())) { //the boid b is close enough...
                double angle = Vector.angleBetween(Vector.sub(velocity, location), Vector.sub(location, b.location));
                if (angle < angleVision){ //... and he is on this field of vision, so it's a neighbour
                  steer.add(b.velocity); //a boid is moving in the same direction of his neighbours
                }
            }
        }

        if (steer.norm() > 0) {
            steer.normalize();
            steer.mult(maxSpeed);
            steer.sub(velocity); //force perpendiculaire à la vitesse.
            steer.limit(maxForce);
        }
        return steer;
    }


    /**
    *Return the vector corresponding to
    *the force "cohesion" applied to the boid by his neighbours
    */
    public Vector cohesion(ArrayList<Boid> boids) {
        Vector target = new Vector(0, 0); //useful to register all the position of the neighbours
        int count = 0; //useful to compute the average position

        for (Boid b : boids) {
            double d = Vector.dist(location, b.location);
            if ((d > 0) && (d < preferredDist)&& (b.getClass()== this.getClass())) {
                double angle = Vector.angleBetween(Vector.sub(velocity, location), Vector.sub(location, b.location));
                if (angle < angleVision){
                  target.add(b.location);
                  count++;
                }
            }
        }
        if (count > 0) { //the boid has at least one neighbour
            target.div(count);
            Vector steer = Vector.sub(target, location);
            steer.normalize();
            steer.mult(maxSpeed);
            steer.sub(velocity); //prend le vecteur normal à la vitesse
            steer.limit(maxForce);
            return steer;
        }
        return target;
    }

    /**
    Apply the force to the vector acceleration
    */
    public void applyForce(Vector force) {
        acceleration.add(force);
    }



    public Vector getLocation(){
      return location;
    }

    public Vector getVelocity(){
      return velocity;
    }

    @Override
    public String toString(){
      String res = "Location: " + location +  "Velocity: " + velocity +"Acceleration: " + acceleration;
      return res;
    }

  }
